<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>CO2 Tolerance Table Trainer</title> <!-- Load Tailwind CSS --> <script src="https://cdn.tailwindcss.com"></script> <style> /* Custom styles for a cleaner look */ body { font-family: 'Inter', sans-serif; background-color: #1a1a2e; /* Deep purple background */ color: #ffffff; display: flex; justify-content: center; align-items: center; min-height: 100vh; } .container-card { background-color: #16213e; /* Slightly lighter card color */ box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); max-width: 600px; } .timer-display { font-size: 4rem; font-weight: 700; line-height: 1; margin: 0.5rem 0; transition: color 0.3s; } .status-prep { color: #4ade80; /* Green for Prep */ } .status-hold { color: #f87171; /* Red for Hold */ } .btn-primary { background-color: #e94560; /* Pinkish-red accent */ transition: background-color 0.2s; } .btn-primary:hover { background-color: #b82643; } </style> </head> <body class="p-4">
<div id="app" class="container-card w-full p-6 sm:p-8 rounded-xl space-y-6">
    <h1 class="text-3xl font-bold text-center text-white">CO₂ Tolerance Table</h1>

    <!-- Safety Warning Section -->
    <div class="bg-yellow-800/50 border border-yellow-500 rounded-lg p-4 text-sm text-yellow-300 space-y-2">
        <h2 class="font-bold text-base text-yellow-100">⚠️ CRITICAL SAFETY WARNING:</h2>
        <ul class="list-disc list-inside space-y-1">
            <li>**NEVER** practice this alone. **ALWAYS** have a spotter present.</li>
            <li>**NEVER** practice this in or near water.</li>
            <li>Stop immediately if you feel dizzy, lightheaded, or intensely uncomfortable.</li>
            <li>**DO NOT** hyperventilate (over-breathe) before the holds. Breathe slowly and comfortably.</li>
        </ul>
    </div>

    <!-- Input Section -->
    <div id="input-section" class="space-y-4">
        <p class="text-sm text-gray-300">Enter your maximum *comfortable* breath-hold time (PB) in seconds. The table's constant hold time will be calculated based on this (approx. 60-70% of PB).</p>
        <div class="flex items-center space-x-3">
            <input
                type="number"
                id="pb-input"
                placeholder="e.g., 90 (seconds)"
                class="w-full p-3 rounded-lg bg-[#27375a] text-white border border-[#3b5998] focus:border-[#e94560] focus:ring focus:ring-[#e94560]/50"
                min="30"
                max="600"
                value="90"
            />
            <button
                id="generate-btn"
                class="btn-primary px-6 py-3 rounded-lg font-semibold whitespace-nowrap"
            >
                Generate Table
            </button>
        </div>
    </div>

    <!-- Timer/Display Section -->
    <div id="timer-section" class="hidden text-center space-y-4">
        <div class="flex justify-center items-center space-x-2 text-xl font-medium text-gray-400">
            <span id="round-display">Round 1 / 8</span>
            <span class="text-gray-600">•</span>
            <span id="hold-target-display">Hold: 00:00</span>
        </div>

        <div id="status-text" class="text-2xl font-semibold text-white">READY</div>
        <div id="timer-value" class="timer-display text-white">00:00</div>

        <button
            id="start-btn"
            class="btn-primary w-full py-3 rounded-lg font-semibold text-lg"
        >
            START SESSION
        </button>
        <button
            id="stop-btn"
            class="bg-gray-700 hover:bg-gray-600 text-white w-full py-3 rounded-lg font-semibold text-lg"
        >
            STOP SESSION
        </button>
    </div>

    <!-- Table Display Area -->
    <div id="table-container" class="mt-6 hidden">
        <h3 class="text-xl font-semibold mb-3 text-center text-[#e94560]">Training Protocol</h3>
        <table class="w-full text-sm text-left rounded-lg overflow-hidden">
            <thead class="text-xs uppercase bg-[#27375a] text-gray-300">
                <tr>
                    <th scope="col" class="px-3 py-2 sm:px-6 sm:py-3">Set</th>
                    <th scope="col" class="px-3 py-2 sm:px-6 sm:py-3">Prep (Recovery)</th>
                    <th scope="col" class="px-3 py-2 sm:px-6 sm:py-3">Hold (Constant)</th>
                </tr>
            </thead>
            <tbody id="co2-table" class="divide-y divide-[#27375a]">
                <!-- Table rows will be inserted here -->
            </tbody>
        </table>
    </div>

    <!-- Session Completion Message -->
    <div id="completion-message" class="hidden text-center p-6 rounded-lg bg-green-900/50 text-green-300">
        <p class="text-xl font-bold mb-2">Session Complete!</p>
        <p>Congratulations! Remember to recover fully and wait at least 24 hours before your next session.</p>
    </div>
</div>

<script>
    // --- Core Variables ---
    const pbInput = document.getElementById('pb-input');
    const generateBtn = document.getElementById('generate-btn');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');

    const inputSection = document.getElementById('input-section');
    const timerSection = document.getElementById('timer-section');
    const tableContainer = document.getElementById('table-container');
    const co2TableBody = document.getElementById('co2-table');
    const completionMessage = document.getElementById('completion-message');

    const roundDisplay = document.getElementById('round-display');
    const holdTargetDisplay = document.getElementById('hold-target-display');
    const statusText = document.getElementById('status-text');
    const timerValue = document.getElementById('timer-value');

    let sessionRunning = false;
    let currentRound = 0;
    let currentPhase = 'PREP'; // 'PREP', 'HOLD', 'RECOVERY'
    let timerInterval;
    let tableData = [];

    // --- Utility Functions ---

    /**
     * Plays a short tone using the Web Audio API.
     * @param {number} freq - Frequency in Hz.
     * @param {number} duration - Duration in seconds.
     */
    function playTone(freq = 440, duration = 0.5) {
        try {
            const context = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq, context.currentTime);
            gainNode.gain.setValueAtTime(0.5, context.currentTime); // Start volume
            gainNode.gain.exponentialRampToValueAtTime(0.00001, context.currentTime + duration); // Fade out

            oscillator.start();
            oscillator.stop(context.currentTime + duration);
        } catch (e) {
            console.error("Audio playback error:", e);
        }
    }

    /**
     * Formats time in seconds into MM:SS.
     * @param {number} totalSeconds
     * @returns {string}
     */
    function formatTime(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // --- Table Generation Logic ---

    function generateTable() {
        const pbSeconds = parseInt(pbInput.value, 10);

        if (isNaN(pbSeconds) || pbSeconds < 30) {
            alertUser("Please enter a comfortable Personal Best time of at least 30 seconds.");
            return;
        }

        // 1. Calculate Constant Hold Time (approx. 66% of PB for a challenging but safe table)
        // Limit to a minimum of 45 seconds if PB is very high to keep the table practical
        const constantHoldTime = Math.max(45, Math.round(pbSeconds * 0.66));
        
        // 2. Define the starting prep time (e.g., 2x the hold time) and the decrease step
        const startPrepTime = constantHoldTime + 60; // Start at holdTime + 60 seconds
        const decreaseStep = 15;
        const rounds = 8;
        tableData = [];

        // 3. Populate the table data
        for (let i = 0; i < rounds; i++) {
            const prepTime = Math.max(15, startPrepTime - (i * decreaseStep));
            tableData.push({
                prep: prepTime,
                hold: constantHoldTime,
                status: 'PENDING' // PENDING, RUNNING, COMPLETED
            });
        }

        // 4. Update the UI - Only show the timer controls, not the table, to keep the setup cleaner.
        renderTable(tableData);

        holdTargetDisplay.textContent = `Hold: ${formatTime(constantHoldTime)}`;
        timerSection.classList.remove('hidden');
        // tableContainer.classList.remove('hidden'); // Table is hidden until session starts
        completionMessage.classList.add('hidden');
        timerValue.textContent = formatTime(tableData[0].prep);
        statusText.textContent = "READY TO START";
    }

    function renderTable(data) {
        co2TableBody.innerHTML = '';
        data.forEach((round, index) => {
            const row = document.createElement('tr');
            row.id = `round-${index + 1}`;
            row.className = `border-b transition-colors ${round.status === 'COMPLETED' ? 'bg-green-900/30 text-gray-500' : 'hover:bg-[#27375a] text-white'}`;
            
            let statusClass = '';
            if (index === currentRound - 1 && sessionRunning) {
                statusClass = currentPhase === 'PREP' ? 'bg-green-600/30 font-bold' : (currentPhase === 'HOLD' ? 'bg-red-600/30 font-bold' : '');
            }

            row.innerHTML = `
                <th scope="row" class="px-3 py-2 sm:px-6 sm:py-3 rounded-l-lg ${statusClass}">
                    ${index + 1}
                </th>
                <td class="px-3 py-2 sm:px-6 sm:py-3 ${statusClass}">
                    ${formatTime(round.prep)}
                </td>
                <td class="px-3 py-2 sm:px-6 sm:py-3 rounded-r-lg ${statusClass}">
                    ${formatTime(round.hold)}
                </td>
            `;
            co2TableBody.appendChild(row);
        });
    }
    
    // Use custom modal for alerts instead of window.alert()
    function alertUser(message) {
        // Simple display of the message in the timer status area for now
        statusText.textContent = message;
        statusText.classList.remove('status-hold', 'status-prep');
        statusText.classList.add('text-yellow-400');
        setTimeout(() => {
            statusText.textContent = "READY";
            statusText.classList.remove('text-yellow-400');
        }, 5000);
    }

    // --- Timer and Session Management ---

    function startSession() {
        if (tableData.length === 0) {
            alertUser("Please generate the training table first.");
            return;
        }

        // This is the "page change" action
        sessionRunning = true;
        currentRound = 1;
        currentPhase = 'PREP';

        startBtn.classList.add('hidden');
        stopBtn.classList.remove('hidden');
        inputSection.classList.add('hidden');          // Hides the setup content
        tableContainer.classList.remove('hidden');  // Shows the full protocol (New Page Content)
        completionMessage.classList.add('hidden');

        runRound();
    }

    function stopSession() {
        clearInterval(timerInterval);
        sessionRunning = false;
        currentRound = 0;
        currentPhase = 'PREP';
        tableData = []; // Clear data to force regeneration
        
        startBtn.classList.remove('hidden');
        stopBtn.classList.add('hidden');
        timerSection.classList.add('hidden');
        tableContainer.classList.add('hidden');
        inputSection.classList.remove('hidden'); // Returns to the setup "page"
        
        timerValue.textContent = '00:00';
        statusText.textContent = 'SESSION ENDED';
    }

    function runRound() {
        if (!sessionRunning) return;

        if (currentRound > tableData.length) {
            // Session is complete
            clearInterval(timerInterval);
            sessionRunning = false;
            timerSection.classList.add('hidden');
            tableContainer.classList.add('hidden');
            completionMessage.classList.remove('hidden');
            inputSection.classList.remove('hidden');
            return;
        }

        const round = tableData[currentRound - 1];
        roundDisplay.textContent = `Round ${currentRound} / ${tableData.length}`;

        // Handle Phase Transitions
        let duration, nextPhase;
        let currentStatusClass, statusTextContent;
        let toneFrequency;
        let countdownStart = 3; // 3 seconds warning

        if (currentPhase === 'PREP') {
            duration = round.prep;
            nextPhase = 'HOLD';
            statusTextContent = 'PREP (Breathe Slowly & Deeply)';
            currentStatusClass = 'status-prep';
            toneFrequency = 500; // Medium tone for prep start
        } else if (currentPhase === 'HOLD') {
            duration = round.hold;
            nextPhase = 'RECOVERY';
            statusTextContent = 'HOLD (Relax & Focus)';
            currentStatusClass = 'status-hold';
            toneFrequency = 700; // Higher tone for hold start
        } else if (currentPhase === 'RECOVERY') {
            // RECOVERY is just the transition back to PREP for the next round
            currentRound++;
            currentPhase = 'PREP';
            
            // Mark previous round as completed
            if (currentRound > 1) {
                tableData[currentRound - 2].status = 'COMPLETED';
            }
            
            runRound(); // Immediately start the next PREP
            return;
        }
        
        // UI Update for new phase
        timerValue.classList.remove('status-prep', 'status-hold', 'text-white');
        timerValue.classList.add(currentStatusClass);
        statusText.textContent = statusTextContent;
        statusText.classList.remove('status-prep', 'status-hold', 'text-white');
        statusText.classList.add(currentStatusClass);
        
        // Play initial tone
        playTone(toneFrequency, 0.5);

        let timeLeft = duration;
        timerValue.textContent = formatTime(timeLeft);
        
        // Render the table to update the current running highlight
        renderTable(tableData);

        clearInterval(timerInterval);
        
        // Use a separate countdown for the last 3 seconds of the PREP and HOLD
        let countdownActive = false;
        
        timerInterval = setInterval(() => {
            timeLeft--;

            if (timeLeft <= countdownStart && timeLeft > 0 && !countdownActive) {
                // Start countdown warning tones
                countdownActive = true;
            }
            
            if (timeLeft >= 0) {
                timerValue.textContent = formatTime(timeLeft);
                
                if (countdownActive) {
                    // Flash and sound on final seconds
                    timerValue.classList.toggle('bg-yellow-500/50');
                    playTone(timeLeft % 2 === 0 ? 800 : 900, 0.1);
                }
            }

            if (timeLeft < 0) {
                clearInterval(timerInterval);
                countdownActive = false; // Reset countdown flag

                // Mark current round as completed for HOLD phase before advancing
                if (currentPhase === 'HOLD') {
                    tableData[currentRound - 1].status = 'COMPLETED';
                }
                
                // Transition to next phase/round
                currentPhase = nextPhase;
                runRound();
            }
        }, 1000);
    }

    // --- Event Listeners ---
    generateBtn.addEventListener('click', generateTable);
    startBtn.addEventListener('click', startSession);
    stopBtn.addEventListener('click', stopSession);

    // Initial table generation on load for better UX
    window.onload = generateTable;

</script>

</body> </html>